# Hyper-NixOS Development Reference

**Version:** 1.0.0
**Last Updated:** 2025-10-17
**Status:** Authoritative Reference

## Purpose

This document is the **authoritative development reference** for Hyper-NixOS. ALL developers (human and AI) MUST follow these patterns and standards when contributing to the project. This consolidates patterns from across the codebase into a single, comprehensive guide.

## Table of Contents

1. [Project Architecture](#project-architecture)
2. [NixOS Module Development](#nixos-module-development)
3. [Bash Script Development](#bash-script-development)
4. [Naming Conventions](#naming-conventions)
5. [Testing Requirements](#testing-requirements)
6. [Common Pitfalls](#common-pitfalls)
7. [Security Patterns](#security-patterns)
8. [File Organization](#file-organization)

---

## Project Architecture

### Directory Structure

```
/home/hyperd/Documents/Hyper-NixOS/
├── configuration.nix              # Main NixOS config entry point
├── hardware-configuration.nix     # Auto-generated hardware detection
├── flake.nix                      # Nix flake for dependency management
├── modules/                       # All NixOS modules (organized by category)
│   ├── core/                      # Foundation (options, system, packages)
│   ├── security/                  # Security layers (privilege, threats, etc)
│   ├── virtualization/            # Libvirt, QEMU, performance
│   ├── features/                  # Feature management system
│   ├── gui/                       # Desktop environment (optional)
│   └── [others]/                  # Networking, monitoring, storage
├── scripts/                       # Operational bash scripts
│   ├── lib/                       # Shared bash libraries
│   │   ├── common.sh              # Core utilities
│   │   ├── ui.sh                  # UI/display functions
│   │   ├── validation.sh          # Input validation
│   │   └── [others]
│   ├── setup/                     # Setup wizards
│   ├── security/                  # Security automation
│   └── [wizard scripts]
├── tools/                         # Rust CLI tools (vmctl, isoctl)
├── docs/                          # Documentation
│   ├── dev/                       # Developer documentation (PROTECTED)
│   ├── user-guides/               # End-user guides
│   └── reference/                 # Technical reference
├── tests/                         # Test suites
│   ├── integration/               # Integration tests
│   └── unit/                      # Unit tests
└── api/                           # GraphQL API (Go)
```

### Module Hierarchy

Modules are loaded in this order (from `configuration.nix`):

1. **Hardware Configuration**: Auto-detected settings
2. **Core Modules**: System foundation (options.nix MUST be first)
3. **System Tiers**: Resource tier definitions (minimal/enhanced/complete)
4. **Feature Management**: Feature categories and dependencies
5. **Security Modules**: Privilege separation, threat detection
6. **Virtualization**: Libvirt, performance tuning
7. **GUI** (optional): Desktop environment
8. **User Features**: Generated by setup wizard

**CRITICAL:** `modules/core/options.nix` MUST be imported before any module that references `config.hypervisor.*` options.

---

## NixOS Module Development

### Standard Module Template

```nix
# Module Description
# Brief explanation of what this module provides

{ config, lib, pkgs, ... }:

let
  inherit (lib) mkOption mkEnableOption mkIf mkDefault mkMerge types;
  cfg = config.hypervisor.category.featureName;

  # Helper functions (if needed)
  helperFn = param: "result-${param}";

in {
  options.hypervisor.category.featureName = {
    enable = mkEnableOption "description of feature";

    someOption = mkOption {
      type = types.str;
      default = "default-value";
      description = "Clear description of what this does";
      example = "example-value";
    };
  };

  config = mkIf cfg.enable {
    # Implementation only when enabled
    # Never access config.* outside of this block in this module

    environment.systemPackages = with pkgs; [
      # Required packages
    ];

    systemd.services.feature-name = {
      description = "Feature Name Service";
      wantedBy = [ "multi-user.target" ];
      serviceConfig = {
        Type = "simple";
        ExecStart = "${pkgs.bash}/bin/bash /path/to/script";
      };
    };
  };
}
```

### Critical Patterns

#### 1. Infinite Recursion Prevention

**NEVER** access `config.*` in top-level `let` bindings:

```nix
# ❌ WRONG - Causes infinite recursion
let
  value = config.hypervisor.someOption;
in {
  config = { ... };
}

# ✅ CORRECT - Access config only inside config block
{
  config = mkIf condition {
    # Access config here
    value = config.hypervisor.someOption;
  };
}
```

#### 2. Library Function Scoping

Always prefix library functions with `lib.` or use `with lib;`:

```nix
# ❌ WRONG - Undefined variable 'elem'
config = mkIf (elem "feature" list) { ... };

# ✅ CORRECT - Properly scoped
config = mkIf (lib.elem "feature" list) { ... };

# ✅ ALSO CORRECT - Using 'with lib;'
{ config, lib, pkgs, ... }:
with lib;
{
  config = mkIf (elem "feature" list) { ... };
}
```

#### 3. Multiline String Escaping

When embedding Python/Bash/scripts in Nix strings, escape single quotes:

```nix
# ❌ WRONG - Syntax error
pkgs.writeText "script.py" ''
  data = threat.get('target', '')
  if 'key' in dict:
      print('hello')
''

# ✅ CORRECT - Escaped single quotes
pkgs.writeText "script.py" ''
  data = threat.get(''target'', '''')
  if ''key'' in dict:
      print(''hello'')
''

# ✅ ALTERNATIVE - Use double quotes in embedded language
pkgs.writeText "script.py" ''
  data = threat.get("target", "")
  if "key" in dict:
      print("hello")
''
```

#### 4. Avoiding Duplicate Attributes

Never define the same attribute twice. Use `mkMerge` to combine:

```nix
# ❌ WRONG - Duplicate definition error
users.users.alice = { ... };
# Later in same file...
users.users.alice = { ... };  # ERROR!

# ✅ CORRECT - Single consolidated definition
users.users = mkMerge [
  {
    alice = { extraGroups = [ "wheel" ]; };
  }
  {
    bob = { extraGroups = [ "libvirtd" ]; };
  }
];
```

#### 5. Conditional Inclusion

Use `mkIf` for conditional configuration:

```nix
config = mkIf cfg.enable {
  # Only applied when feature is enabled

  # Nested conditionals
  services.something = mkIf cfg.advanced {
    enable = true;
  };
};
```

#### 6. Option Types Reference

```nix
# Common types
type = types.bool;                    # true/false
type = types.str;                     # String
type = types.int;                     # Integer
type = types.path;                    # File path
type = types.package;                 # Nix package
type = types.listOf types.str;        # List of strings
type = types.attrsOf types.int;       # Attribute set {key = int;}
type = types.enum [ "a" "b" "c" ];    # One of specified values
type = types.nullOr types.str;        # String or null
```

---

## Bash Script Development

### Standard Script Template

```bash
#!/usr/bin/env bash
# shellcheck disable=SC2034,SC1091
#
# Script Name - Brief Description
#
# Copyright (C) 2024-2025 MasterofNull
# Licensed under GPL v3.0
#
# Detailed description of what this script does
# and when it should be used.
#

# Strict error handling
set -Eeuo pipefail
IFS=$'\n\t'

# Script metadata
readonly SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
readonly SCRIPT_VERSION="1.0.0"

# Sudo requirements declaration (REQUIRED)
readonly REQUIRES_SUDO=false  # or true
readonly OPERATION_TYPE="vm_management"  # or "system_config"

# Source shared libraries (adjust path as needed)
SCRIPT_ROOT="${SCRIPT_DIR%/*}"  # Parent of scripts/
source "${SCRIPT_ROOT}/scripts/lib/common.sh"
source "${SCRIPT_ROOT}/scripts/lib/ui.sh"

# Script-specific functions
main() {
    # Check sudo if required
    if [[ "$REQUIRES_SUDO" == "true" ]] && [[ $EUID -ne 0 ]]; then
        error "This script requires sudo. Please run: sudo $0"
        exit 1
    fi

    # Main logic here
    log_info "Script started: $SCRIPT_NAME"

    # Your code

    log_info "Script completed successfully"
}

# Run main
main "$@"
```

### Key Bash Patterns

#### 1. Error Handling

```bash
# Always use strict mode
set -Eeuo pipefail

# Exit codes (from common.sh)
readonly EXIT_SUCCESS=0
readonly EXIT_GENERAL_ERROR=1
readonly EXIT_PERMISSION_DENIED=13
readonly EXIT_NOT_FOUND=127

# Error function (from common.sh)
error() {
    echo -e "${RED}ERROR:${NC} $*" >&2
    log_error "$*"
}

die() {
    error "$*"
    exit "${2:-1}"
}
```

#### 2. Input Validation

```bash
# Use validation functions from lib/validation.sh
validate_vm_name() {
    local name="$1"
    # Only allow alphanumeric, dash, underscore
    if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        error "Invalid VM name: $name"
        return 1
    fi
}

validate_ip() {
    local ip="$1"
    if [[ ! "$ip" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        error "Invalid IP address: $ip"
        return 1
    fi
}

# Always validate user input
read -rp "Enter VM name: " vm_name
validate_vm_name "$vm_name" || exit 1
```

#### 3. Logging

```bash
# Initialize logging (from common.sh)
init_logging "script-name"

# Log at different levels
log_info "Informational message"
log_warn "Warning message"
log_error "Error occurred"
log_debug "Debug info (only if DEBUG=true)"
```

#### 4. UI Elements

```bash
# Source UI library for consistent formatting
source "${SCRIPT_ROOT}/scripts/lib/ui.sh"

# Print colored output
success "Operation completed"
warning "This is a warning"
error "An error occurred"
info "Informational message"

# Headers and sections
print_header "Script Name"
print_section "Configuration"

# Progress indicators
show_spinner "Loading..." &
SPINNER_PID=$!
# ... long operation ...
kill $SPINNER_PID 2>/dev/null
```

#### 5. Cleanup Handlers

```bash
# Register cleanup function (from common.sh)
cleanup() {
    rm -f /tmp/tempfile
    log_info "Cleanup completed"
}

_register_cleanup cleanup

# Cleanup runs automatically on exit via trap
```

#### 6. Privilege Separation

```bash
# Check group membership for VM operations (no sudo needed)
check_vm_group_membership() {
    if ! groups | grep -qE '(libvirtd|hypervisor-users)'; then
        error "You must be in 'libvirtd' or 'hypervisor-users' group"
        error "Ask admin to run: sudo usermod -aG libvirtd $USER"
        return "$EXIT_PERMISSION_DENIED"
    fi
}

# For system operations, require explicit sudo
if [[ "$REQUIRES_SUDO" == "true" ]]; then
    require_sudo() {
        if [[ $EUID -ne 0 ]]; then
            error "This operation requires sudo"
            error "Please run: sudo $0 $*"
            exit "$EXIT_PERMISSION_DENIED"
        fi
    }
fi
```

---

## Naming Conventions

### File Naming

- **Scripts**: Use dash-separated lowercase: `feature-manager-wizard.sh`
- **Modules**: Use dash-separated lowercase: `privilege-separation.nix`
- **Libraries**: Use dash-separated lowercase: `risk-notifications.sh`
- **Documentation**: Use UPPERCASE or PascalCase: `README.md`, `SECURITY.md`

### Variable Naming

```bash
# Constants: UPPERCASE with underscores
readonly MAX_RETRIES=3
readonly DEFAULT_TIMEOUT=30

# Local variables: lowercase with underscores
local vm_name="test-vm"
local retry_count=0

# Environment variables: UPPERCASE
export HYPERVISOR_ROOT="/etc/hypervisor"
```

```nix
# NixOS options: camelCase
hypervisor.security.enableThreatDetection

# Local bindings: camelCase
cfg = config.hypervisor.feature;
packageList = [ pkgs.vim pkgs.git ];
```

### Function Naming

```bash
# Bash functions: lowercase with underscores
function check_prerequisites() {
    # ...
}

function create_vm_disk() {
    # ...
}
```

```nix
# Nix functions: camelCase
mkSudoRule = group: commands: { ... };
filterEnabled = list: filter (x: x.enable) list;
```

---

## Testing Requirements

### Unit Tests

Located in `tests/unit/`, test individual functions and modules.

```bash
#!/usr/bin/env bash
# test_validation.sh

source ../scripts/lib/validation.sh

# Test function
test_validate_vm_name() {
    # Valid names
    validate_vm_name "test-vm" || return 1
    validate_vm_name "vm_123" || return 1

    # Invalid names (should fail)
    ! validate_vm_name "test vm" || return 1  # Space
    ! validate_vm_name "test@vm" || return 1  # Special char

    return 0
}

# Run test
test_validate_vm_name && echo "PASS" || echo "FAIL"
```

### Integration Tests

Located in `tests/integration/`, test complete workflows.

```bash
#!/usr/bin/env bash
# test_vm_creation.sh

# CI detection
if [[ "${CI:-false}" == "true" ]]; then
    echo "Skipping VM creation test in CI environment"
    exit 0
fi

# Setup
source ../scripts/lib/common.sh
init_logging "test-vm-creation"

# Test VM creation workflow
test_create_and_start_vm() {
    local vm_name="test-vm-$$"

    # Create VM
    ../scripts/create-vm-wizard.sh --non-interactive \
        --name "$vm_name" \
        --memory 1024 \
        --disk 10G || return 1

    # Verify creation
    virsh list --all | grep -q "$vm_name" || return 1

    # Cleanup
    virsh undefine "$vm_name" --remove-all-storage

    return 0
}

test_create_and_start_vm && echo "PASS" || echo "FAIL"
```

### CI/CD Considerations

```bash
# Always check CI environment variable
if [[ "${CI:-false}" == "true" ]]; then
    # Skip system-dependent tests
    # Mock hardware checks
    # Use temporary directories
fi

# Use configurable paths, not hardcoded
HYPERVISOR_ROOT="${HYPERVISOR_ROOT:-/etc/hypervisor}"

# Setup environment BEFORE sourcing libraries
export HYPERVISOR_LOGS="$TEST_DIR/logs"
mkdir -p "$HYPERVISOR_LOGS"
source common.sh
```

### Test Coverage Requirements

- **Minimum:** 80% code coverage for new features
- **Critical paths:** 100% coverage for security and privilege code
- **Integration tests:** All user-facing wizards
- **Performance tests:** Baseline metrics for VM operations

---

## Common Pitfalls

### 1. Infinite Recursion in Modules

**Problem:** Accessing `config` in let bindings causes infinite recursion.

**Solution:** Only access `config` inside the `config = mkIf` block.

```nix
# ❌ WRONG
let
  value = config.hypervisor.someOption;
in { config = { ... }; }

# ✅ CORRECT
{ config = mkIf condition {
    value = config.hypervisor.someOption;
  };
}
```

### 2. Missing Library Prefix

**Problem:** `error: undefined variable 'elem'`

**Solution:** Use `lib.elem` or add `with lib;`

### 3. Duplicate Attribute Definitions

**Problem:** `error: attribute 'X' already defined`

**Solution:** Consolidate into single `mkMerge` block

### 4. Test Script Exit on Failure

**Problem:** Test scripts exit early when library functions call `exit`

**Solution:** Use subshells or disable strict mode for tests

```bash
# In tests, allow failures
set +e
(function_that_might_exit) || echo "Failed as expected"
set -e
```

### 5. Readonly Variables in CI

**Problem:** CI tests fail with "readonly variable" errors

**Solution:** Remove `readonly` declarations before sourcing in tests

```bash
# In test setup
sed -i 's/^readonly HYPERVISOR_/HYPERVISOR_/g' "$TEMP/common.sh"
source "$TEMP/common.sh"
```

### 6. Hardcoded Paths

**Problem:** Tests fail in CI due to hardcoded paths like `/etc/hypervisor`

**Solution:** Use environment variables with defaults

```bash
HYPERVISOR_ROOT="${HYPERVISOR_ROOT:-/etc/hypervisor}"
```

### 7. Missing Dependencies in CI

**Problem:** Commands like `virsh`, `qemu-img` not available in CI

**Solution:** Check for dependencies and skip gracefully

```bash
if ! command -v virsh &>/dev/null; then
    echo "virsh not available, skipping test"
    exit 0
fi
```

---

## Security Patterns

### Privilege Model

```bash
# VM Operations: NO sudo required (users in libvirtd group)
virsh list --all
virsh start vm-name
virsh console vm-name

# System Operations: REQUIRE sudo
sudo nixos-rebuild switch
sudo systemctl restart libvirtd
sudo hv system-config
```

### Input Validation

```bash
# ALWAYS validate user input
validate_before_use() {
    local input="$1"

    # Check format
    [[ "$input" =~ ^[a-zA-Z0-9_-]+$ ]] || die "Invalid format"

    # Check length
    [[ ${#input} -le 64 ]] || die "Too long"

    # Check against whitelist if applicable
    local valid_options=("option1" "option2" "option3")
    [[ " ${valid_options[*]} " =~ " ${input} " ]] || die "Not in whitelist"
}
```

### Path Safety

```bash
# Prevent path traversal
sanitize_path() {
    local path="$1"
    # Remove ../ sequences
    path="${path//..\/}"
    # Ensure absolute path
    [[ "$path" =~ ^/ ]] || path="/$path"
    echo "$path"
}
```

### Secret Handling

```bash
# NEVER log secrets
log_info "Connecting to ${HOSTNAME}"  # Good
log_info "Using password ${PASSWORD}"  # BAD!

# Use secure temporary files
secret_file=$(mktemp -t secret.XXXXXX)
chmod 600 "$secret_file"
_register_cleanup "rm -f $secret_file"
```

---

## File Organization

### Module Organization

```
modules/
├── core/                   # Foundation (MUST be imported first)
│   ├── options.nix         # ALL option definitions (import FIRST)
│   ├── hypervisor-base.nix # Base configuration
│   ├── system.nix          # System settings
│   └── packages.nix        # Default packages
├── security/               # Security components
│   ├── base.nix            # Security foundation
│   ├── profiles.nix        # Security profiles
│   ├── privilege-separation.nix
│   └── threat-detection.nix
└── features/               # Feature management
    ├── feature-categories.nix
    └── feature-manager.nix
```

### Script Organization

```
scripts/
├── lib/                    # Shared libraries (ALWAYS source these)
│   ├── common.sh           # Core utilities, logging, validation
│   ├── ui.sh               # Display and formatting
│   ├── validation.sh       # Input validation functions
│   └── risk-notifications.sh  # Risk notification display
├── setup/                  # Setup and configuration wizards
├── security/               # Security-specific tools
└── [wizard-name]-wizard.sh # Top-level wizards
```

### Documentation Organization

```
docs/
├── dev/                    # Developer docs (PROTECTED - see README)
│   ├── DEVELOPMENT_REFERENCE.md  # THIS FILE (authoritative)
│   ├── AI_ASSISTANT_CONTEXT.md   # AI agent context
│   ├── CRITICAL_REQUIREMENTS.md  # Mandatory requirements
│   └── AI-LESSONS-LEARNED.md     # Historical lessons
├── user-guides/            # End-user documentation
├── reference/              # Technical reference materials
└── QUICK_START.md          # New user getting started
```

---

## Development Workflow

### Before Starting Work

1. **Read this document completely**
2. Review `/docs/dev/CRITICAL_REQUIREMENTS.md`
3. Check `/docs/CHANGELOG.md` for recent changes
4. Review related modules/scripts for patterns

### During Development

1. **Follow patterns** from this document exactly
2. **Document decisions** as you make them
3. **Test incrementally** - don't wait until the end
4. **Update documentation** as you change code
5. **Run tests** after each significant change

### Before Committing

1. **Run full test suite**: `./tests/run_all_tests.sh`
2. **Verify NixOS syntax**: `nixos-rebuild dry-build`
3. **Check for TODOs/FIXMEs** you added
4. **Update CHANGELOG.md** with your changes
5. **Update this file** if you discovered new patterns

---

## Getting Help

### Resources

- **This document**: Authoritative reference for development
- **AI_ASSISTANT_CONTEXT.md**: High-level project context
- **CRITICAL_REQUIREMENTS.md**: Mandatory rules and requirements
- **AI-LESSONS-LEARNED.md**: Historical issues and solutions
- **Module examples**: Look at existing modules in `modules/`
- **Script examples**: Look at existing scripts in `scripts/`

### Common Commands

```bash
# Test NixOS configuration syntax
nixos-rebuild dry-build

# Test configuration with detailed errors
nixos-rebuild dry-build --show-trace

# Run full test suite
./tests/run_all_tests.sh

# Run specific test
./tests/unit/test_validation.sh

# Check module for infinite recursion
nix eval .#nixosConfigurations.hypervisor-x86_64.config.system.build --show-trace

# Lint shell scripts
shellcheck scripts/*.sh

# Format Nix code
nixpkgs-fmt configuration.nix modules/**/*.nix
```

---

## Version History

- **1.0.0** (2025-10-17): Initial comprehensive reference consolidating all development patterns

---

**Remember:** This is the authoritative source. When in doubt, refer to this document. If something is unclear or missing, update this document to help future developers.
