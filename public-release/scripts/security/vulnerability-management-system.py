#!/usr/bin/env python3
"""
Automated Vulnerability Management System
Tracks, prioritizes, and manages vulnerabilities across the infrastructure
"""

import asyncio
import json
import sqlite3
from pathlib import Path
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, Tuple
import logging
import subprocess
from dataclasses import dataclass, field
from enum import Enum
import hashlib
import requests
import yaml

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class VulnerabilityStatus(Enum):
    """Vulnerability status enum"""
    NEW = "new"
    TRIAGED = "triaged"
    IN_PROGRESS = "in_progress"
    MITIGATED = "mitigated"
    ACCEPTED = "accepted"
    FALSE_POSITIVE = "false_positive"


class Severity(Enum):
    """Severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class Vulnerability:
    """Represents a vulnerability"""
    vuln_id: str
    cve_id: Optional[str]
    title: str
    description: str
    severity: Severity
    cvss_score: Optional[float]
    affected_component: str
    affected_version: str
    fixed_version: Optional[str]
    discovered_date: datetime
    status: VulnerabilityStatus
    remediation: Optional[str]
    references: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    risk_score: int = 0
    priority: int = 0


@dataclass
class VulnerabilityPatch:
    """Represents a patch or fix for a vulnerability"""
    patch_id: str
    vuln_id: str
    patch_type: str  # update, configuration, workaround
    description: str
    commands: List[str]
    test_commands: List[str]
    rollback_commands: List[str]
    estimated_downtime: int  # minutes
    risk_level: str  # low, medium, high
    tested: bool = False
    applied: bool = False
    applied_date: Optional[datetime] = None


class VulnerabilityDatabase:
    """SQLite database for vulnerability tracking"""
    
    def __init__(self, db_path: str = "/var/lib/security/vulnerabilities.db"):
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self.init_database()
    
    def init_database(self):
        """Initialize database schema"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        # Vulnerabilities table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                vuln_id TEXT PRIMARY KEY,
                cve_id TEXT,
                title TEXT NOT NULL,
                description TEXT,
                severity TEXT NOT NULL,
                cvss_score REAL,
                affected_component TEXT NOT NULL,
                affected_version TEXT,
                fixed_version TEXT,
                discovered_date TIMESTAMP,
                status TEXT NOT NULL,
                remediation TEXT,
                references TEXT,
                tags TEXT,
                risk_score INTEGER,
                priority INTEGER,
                last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Patches table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS patches (
                patch_id TEXT PRIMARY KEY,
                vuln_id TEXT NOT NULL,
                patch_type TEXT NOT NULL,
                description TEXT,
                commands TEXT,
                test_commands TEXT,
                rollback_commands TEXT,
                estimated_downtime INTEGER,
                risk_level TEXT,
                tested BOOLEAN DEFAULT FALSE,
                applied BOOLEAN DEFAULT FALSE,
                applied_date TIMESTAMP,
                FOREIGN KEY (vuln_id) REFERENCES vulnerabilities (vuln_id)
            )
        ''')
        
        # Scan history table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS scan_history (
                scan_id TEXT PRIMARY KEY,
                scan_date TIMESTAMP,
                scan_type TEXT,
                target TEXT,
                vulnerabilities_found INTEGER,
                new_vulnerabilities INTEGER,
                scan_duration INTEGER
            )
        ''')
        
        # Remediation history
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS remediation_history (
                remediation_id TEXT PRIMARY KEY,
                vuln_id TEXT NOT NULL,
                action_type TEXT,
                action_date TIMESTAMP,
                performed_by TEXT,
                success BOOLEAN,
                notes TEXT,
                FOREIGN KEY (vuln_id) REFERENCES vulnerabilities (vuln_id)
            )
        ''')
        
        # Create indexes
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_vuln_severity ON vulnerabilities(severity)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_vuln_status ON vulnerabilities(status)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_vuln_component ON vulnerabilities(affected_component)')
        
        conn.commit()
        conn.close()
    
    def add_vulnerability(self, vuln: Vulnerability) -> bool:
        """Add vulnerability to database"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                INSERT OR REPLACE INTO vulnerabilities 
                (vuln_id, cve_id, title, description, severity, cvss_score,
                 affected_component, affected_version, fixed_version,
                 discovered_date, status, remediation, references, tags,
                 risk_score, priority)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                vuln.vuln_id,
                vuln.cve_id,
                vuln.title,
                vuln.description,
                vuln.severity.value,
                vuln.cvss_score,
                vuln.affected_component,
                vuln.affected_version,
                vuln.fixed_version,
                vuln.discovered_date.isoformat(),
                vuln.status.value,
                vuln.remediation,
                json.dumps(vuln.references),
                json.dumps(vuln.tags),
                vuln.risk_score,
                vuln.priority
            ))
            
            conn.commit()
            return True
            
        except Exception as e:
            logger.error(f"Error adding vulnerability: {str(e)}")
            return False
        finally:
            conn.close()
    
    def get_vulnerabilities(self, status: Optional[VulnerabilityStatus] = None,
                          severity: Optional[Severity] = None,
                          component: Optional[str] = None) -> List[Dict[str, Any]]:
        """Get vulnerabilities with optional filters"""
        conn = sqlite3.connect(str(self.db_path))
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        query = "SELECT * FROM vulnerabilities WHERE 1=1"
        params = []
        
        if status:
            query += " AND status = ?"
            params.append(status.value)
        
        if severity:
            query += " AND severity = ?"
            params.append(severity.value)
        
        if component:
            query += " AND affected_component LIKE ?"
            params.append(f"%{component}%")
        
        query += " ORDER BY priority DESC, risk_score DESC"
        
        cursor.execute(query, params)
        results = [dict(row) for row in cursor.fetchall()]
        
        conn.close()
        return results
    
    def update_vulnerability_status(self, vuln_id: str, status: VulnerabilityStatus,
                                  notes: Optional[str] = None) -> bool:
        """Update vulnerability status"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                UPDATE vulnerabilities 
                SET status = ?, last_updated = CURRENT_TIMESTAMP
                WHERE vuln_id = ?
            ''', (status.value, vuln_id))
            
            # Add to remediation history
            if notes:
                cursor.execute('''
                    INSERT INTO remediation_history
                    (remediation_id, vuln_id, action_type, action_date, notes)
                    VALUES (?, ?, ?, ?, ?)
                ''', (
                    f"rem_{datetime.now().timestamp()}",
                    vuln_id,
                    f"status_change_to_{status.value}",
                    datetime.now().isoformat(),
                    notes
                ))
            
            conn.commit()
            return True
            
        except Exception as e:
            logger.error(f"Error updating vulnerability status: {str(e)}")
            return False
        finally:
            conn.close()


class VulnerabilityScanner:
    """Scans for vulnerabilities using various tools"""
    
    def __init__(self, db: VulnerabilityDatabase):
        self.db = db
        self.scanners = {
            'trivy': self._scan_with_trivy,
            'grype': self._scan_with_grype,
            'clair': self._scan_with_clair
        }
    
    async def scan_image(self, image: str, scanner: str = 'trivy') -> List[Vulnerability]:
        """Scan container image for vulnerabilities"""
        if scanner not in self.scanners:
            raise ValueError(f"Unknown scanner: {scanner}")
        
        return await self.scanners[scanner](image)
    
    async def scan_filesystem(self, path: str) -> List[Vulnerability]:
        """Scan filesystem for vulnerabilities"""
        return await self._scan_with_trivy(f"fs:{path}")
    
    async def _scan_with_trivy(self, target: str) -> List[Vulnerability]:
        """Scan using Trivy"""
        vulnerabilities = []
        
        try:
            # Determine scan type
            if target.startswith("fs:"):
                cmd = ['trivy', 'fs', '--format', 'json', target[3:]]
            else:
                cmd = ['trivy', 'image', '--format', 'json', target]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode not in [0, 1]:
                logger.error(f"Trivy scan failed: {stderr.decode()}")
                return vulnerabilities
            
            # Parse results
            data = json.loads(stdout.decode())
            
            for result in data.get('Results', []):
                target_name = result.get('Target', 'unknown')
                
                for vuln in result.get('Vulnerabilities', []):
                    vuln_id = self._generate_vuln_id(
                        vuln.get('VulnerabilityID'),
                        vuln.get('PkgName'),
                        target_name
                    )
                    
                    vulnerability = Vulnerability(
                        vuln_id=vuln_id,
                        cve_id=vuln.get('VulnerabilityID'),
                        title=vuln.get('Title', vuln.get('VulnerabilityID')),
                        description=vuln.get('Description', ''),
                        severity=self._map_severity(vuln.get('Severity', 'UNKNOWN')),
                        cvss_score=self._extract_cvss_score(vuln),
                        affected_component=f"{target_name}:{vuln.get('PkgName')}",
                        affected_version=vuln.get('InstalledVersion', ''),
                        fixed_version=vuln.get('FixedVersion'),
                        discovered_date=datetime.now(),
                        status=VulnerabilityStatus.NEW,
                        remediation=self._generate_remediation(vuln),
                        references=vuln.get('References', [])
                    )
                    
                    # Calculate risk score
                    vulnerability.risk_score = self._calculate_risk_score(vulnerability)
                    
                    vulnerabilities.append(vulnerability)
            
        except Exception as e:
            logger.error(f"Error in Trivy scan: {str(e)}")
        
        return vulnerabilities
    
    async def _scan_with_grype(self, target: str) -> List[Vulnerability]:
        """Scan using Grype (placeholder)"""
        # Implementation would be similar to Trivy
        return []
    
    async def _scan_with_clair(self, target: str) -> List[Vulnerability]:
        """Scan using Clair (placeholder)"""
        # Implementation would integrate with Clair API
        return []
    
    def _generate_vuln_id(self, cve_id: str, package: str, target: str) -> str:
        """Generate unique vulnerability ID"""
        content = f"{cve_id}:{package}:{target}"
        return hashlib.sha256(content.encode()).hexdigest()[:16]
    
    def _map_severity(self, severity: str) -> Severity:
        """Map scanner severity to our enum"""
        mapping = {
            'CRITICAL': Severity.CRITICAL,
            'HIGH': Severity.HIGH,
            'MEDIUM': Severity.MEDIUM,
            'LOW': Severity.LOW,
            'UNKNOWN': Severity.INFO
        }
        return mapping.get(severity.upper(), Severity.INFO)
    
    def _extract_cvss_score(self, vuln: Dict[str, Any]) -> Optional[float]:
        """Extract CVSS score from vulnerability data"""
        # Try different CVSS score fields
        for field in ['CVSS', 'Cvss', 'cvss']:
            if field in vuln:
                cvss_data = vuln[field]
                # Look for score in different formats
                if isinstance(cvss_data, dict):
                    for score_field in ['Score', 'score', 'BaseScore']:
                        if score_field in cvss_data:
                            try:
                                return float(cvss_data[score_field])
                            except:
                                pass
        return None
    
    def _calculate_risk_score(self, vuln: Vulnerability) -> int:
        """Calculate risk score based on various factors"""
        score = 0
        
        # Base score from severity
        severity_scores = {
            Severity.CRITICAL: 40,
            Severity.HIGH: 30,
            Severity.MEDIUM: 20,
            Severity.LOW: 10,
            Severity.INFO: 5
        }
        score += severity_scores.get(vuln.severity, 0)
        
        # CVSS score contribution
        if vuln.cvss_score:
            score += int(vuln.cvss_score * 5)
        
        # Exploitability factors
        if 'exploit' in vuln.title.lower() or any('exploit' in ref.lower() for ref in vuln.references):
            score += 20
        
        # Age factor (newer vulnerabilities might be more dangerous)
        age_days = (datetime.now() - vuln.discovered_date).days
        if age_days < 30:
            score += 10
        
        # Component criticality (hardcoded for demo, should be configurable)
        critical_components = ['kernel', 'openssl', 'ssh', 'sudo', 'docker']
        if any(comp in vuln.affected_component.lower() for comp in critical_components):
            score += 15
        
        return min(score, 100)
    
    def _generate_remediation(self, vuln: Dict[str, Any]) -> str:
        """Generate remediation advice"""
        if vuln.get('FixedVersion'):
            return f"Update to version {vuln['FixedVersion']}"
        
        if vuln.get('VulnerabilityID', '').startswith('CVE-'):
            return f"Apply security patches for {vuln['VulnerabilityID']}"
        
        return "Review and apply vendor-recommended mitigations"


class VulnerabilityPrioritizer:
    """Prioritizes vulnerabilities based on risk and business impact"""
    
    def __init__(self, db: VulnerabilityDatabase):
        self.db = db
        self.asset_criticality = self._load_asset_criticality()
    
    def _load_asset_criticality(self) -> Dict[str, int]:
        """Load asset criticality scores"""
        # In production, this would load from configuration
        return {
            'production': 10,
            'database': 9,
            'web-server': 8,
            'api': 8,
            'development': 5,
            'test': 3
        }
    
    async def prioritize_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """Prioritize vulnerabilities based on multiple factors"""
        for vuln in vulnerabilities:
            # Calculate priority score
            priority = 0
            
            # Risk score contribution
            priority += vuln.risk_score
            
            # Asset criticality
            for asset_type, criticality in self.asset_criticality.items():
                if asset_type in vuln.affected_component.lower():
                    priority += criticality * 5
                    break
            
            # Ease of exploitation
            if vuln.cvss_score and vuln.cvss_score > 7.0:
                priority += 20
            
            # Patch availability
            if vuln.fixed_version:
                priority += 10  # Easier to fix
            else:
                priority -= 5   # Harder to fix
            
            # Public exploit availability (would check exploit databases in production)
            if 'exploit' in ' '.join(vuln.tags).lower():
                priority += 25
            
            vuln.priority = min(priority, 100)
        
        # Sort by priority
        vulnerabilities.sort(key=lambda v: v.priority, reverse=True)
        
        return vulnerabilities


class RemediationEngine:
    """Automates vulnerability remediation"""
    
    def __init__(self, db: VulnerabilityDatabase):
        self.db = db
        self.remediation_strategies = {
            'package_update': self._remediate_package_update,
            'configuration': self._remediate_configuration,
            'workaround': self._apply_workaround,
            'container_rebuild': self._rebuild_container
        }
    
    async def generate_remediation_plan(self, vuln_id: str) -> Optional[VulnerabilityPatch]:
        """Generate remediation plan for vulnerability"""
        # Get vulnerability details
        vulns = self.db.get_vulnerabilities()
        vuln_data = next((v for v in vulns if v['vuln_id'] == vuln_id), None)
        
        if not vuln_data:
            return None
        
        # Determine remediation strategy
        if vuln_data.get('fixed_version'):
            return await self._create_update_patch(vuln_data)
        
        # Check for known workarounds
        if self._has_known_workaround(vuln_data):
            return await self._create_workaround_patch(vuln_data)
        
        return None
    
    async def _create_update_patch(self, vuln_data: Dict[str, Any]) -> VulnerabilityPatch:
        """Create patch for package update"""
        component = vuln_data['affected_component']
        fixed_version = vuln_data['fixed_version']
        
        # Determine package manager
        if 'apt' in component or 'deb' in component:
            update_cmd = f"apt-get update && apt-get install -y {component.split(':')[-1]}={fixed_version}"
            test_cmd = f"dpkg -l | grep {component.split(':')[-1]}"
        elif 'npm' in component:
            package_name = component.split(':')[-1]
            update_cmd = f"npm install {package_name}@{fixed_version}"
            test_cmd = f"npm list {package_name}"
        elif 'pip' in component or 'python' in component:
            package_name = component.split(':')[-1]
            update_cmd = f"pip install --upgrade {package_name}=={fixed_version}"
            test_cmd = f"pip show {package_name}"
        else:
            # Generic update
            update_cmd = f"echo 'Manual update required for {component} to {fixed_version}'"
            test_cmd = "echo 'Manual verification required'"
        
        return VulnerabilityPatch(
            patch_id=f"patch_{vuln_data['vuln_id']}_{datetime.now().timestamp()}",
            vuln_id=vuln_data['vuln_id'],
            patch_type='update',
            description=f"Update {component} to {fixed_version}",
            commands=[update_cmd],
            test_commands=[test_cmd],
            rollback_commands=[f"echo 'Rollback not automated'"],
            estimated_downtime=5,
            risk_level='medium'
        )
    
    async def _create_workaround_patch(self, vuln_data: Dict[str, Any]) -> VulnerabilityPatch:
        """Create workaround patch"""
        # This would contain a database of known workarounds
        # For demo, return a generic workaround
        return VulnerabilityPatch(
            patch_id=f"workaround_{vuln_data['vuln_id']}_{datetime.now().timestamp()}",
            vuln_id=vuln_data['vuln_id'],
            patch_type='workaround',
            description=f"Apply workaround for {vuln_data['title']}",
            commands=["echo 'Apply manual workaround as per vendor advisory'"],
            test_commands=["echo 'Verify workaround effectiveness'"],
            rollback_commands=["echo 'Remove workaround configuration'"],
            estimated_downtime=0,
            risk_level='low'
        )
    
    def _has_known_workaround(self, vuln_data: Dict[str, Any]) -> bool:
        """Check if vulnerability has known workaround"""
        # In production, this would check a knowledge base
        return 'workaround' in vuln_data.get('remediation', '').lower()
    
    async def apply_patch(self, patch: VulnerabilityPatch, dry_run: bool = True) -> bool:
        """Apply vulnerability patch"""
        logger.info(f"Applying patch {patch.patch_id} for vulnerability {patch.vuln_id}")
        
        if dry_run:
            logger.info("DRY RUN - Commands that would be executed:")
            for cmd in patch.commands:
                logger.info(f"  {cmd}")
            return True
        
        try:
            # Execute patch commands
            for cmd in patch.commands:
                logger.info(f"Executing: {cmd}")
                process = await asyncio.create_subprocess_shell(
                    cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                
                if process.returncode != 0:
                    logger.error(f"Command failed: {stderr.decode()}")
                    # Attempt rollback
                    await self._rollback_patch(patch)
                    return False
            
            # Run tests
            for test_cmd in patch.test_commands:
                logger.info(f"Testing: {test_cmd}")
                process = await asyncio.create_subprocess_shell(
                    test_cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                
                if process.returncode != 0:
                    logger.error(f"Test failed: {stderr.decode()}")
                    await self._rollback_patch(patch)
                    return False
            
            # Mark as applied
            patch.applied = True
            patch.applied_date = datetime.now()
            
            # Update vulnerability status
            self.db.update_vulnerability_status(
                patch.vuln_id,
                VulnerabilityStatus.MITIGATED,
                f"Applied patch {patch.patch_id}"
            )
            
            return True
            
        except Exception as e:
            logger.error(f"Error applying patch: {str(e)}")
            await self._rollback_patch(patch)
            return False
    
    async def _rollback_patch(self, patch: VulnerabilityPatch):
        """Rollback a patch"""
        logger.warning(f"Rolling back patch {patch.patch_id}")
        
        for cmd in patch.rollback_commands:
            try:
                process = await asyncio.create_subprocess_shell(
                    cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await process.communicate()
            except Exception as e:
                logger.error(f"Rollback error: {str(e)}")


class VulnerabilityManagementSystem:
    """Main vulnerability management system"""
    
    def __init__(self):
        self.db = VulnerabilityDatabase()
        self.scanner = VulnerabilityScanner(self.db)
        self.prioritizer = VulnerabilityPrioritizer(self.db)
        self.remediation = RemediationEngine(self.db)
        self.scan_interval = 3600  # 1 hour
    
    async def scan_environment(self, targets: List[str]) -> Dict[str, Any]:
        """Scan entire environment for vulnerabilities"""
        scan_id = f"scan_{datetime.now().timestamp()}"
        start_time = datetime.now()
        
        all_vulnerabilities = []
        new_vulnerabilities = []
        
        for target in targets:
            logger.info(f"Scanning {target}")
            
            # Determine target type and scan
            if target.startswith('/'):
                # Filesystem scan
                vulns = await self.scanner.scan_filesystem(target)
            else:
                # Container image scan
                vulns = await self.scanner.scan_image(target)
            
            # Check for new vulnerabilities
            for vuln in vulns:
                existing = self.db.get_vulnerabilities()
                if not any(v['vuln_id'] == vuln.vuln_id for v in existing):
                    new_vulnerabilities.append(vuln)
                    self.db.add_vulnerability(vuln)
                
                all_vulnerabilities.append(vuln)
        
        # Prioritize vulnerabilities
        prioritized = await self.prioritizer.prioritize_vulnerabilities(all_vulnerabilities)
        
        # Update priorities in database
        for vuln in prioritized:
            self.db.add_vulnerability(vuln)  # This will update existing entries
        
        # Record scan history
        duration = (datetime.now() - start_time).seconds
        
        scan_summary = {
            'scan_id': scan_id,
            'scan_date': start_time.isoformat(),
            'targets_scanned': len(targets),
            'total_vulnerabilities': len(all_vulnerabilities),
            'new_vulnerabilities': len(new_vulnerabilities),
            'critical_count': sum(1 for v in all_vulnerabilities if v.severity == Severity.CRITICAL),
            'high_count': sum(1 for v in all_vulnerabilities if v.severity == Severity.HIGH),
            'scan_duration': duration
        }
        
        return scan_summary
    
    async def generate_report(self, format: str = 'json') -> str:
        """Generate vulnerability report"""
        vulns = self.db.get_vulnerabilities(status=VulnerabilityStatus.NEW)
        
        if format == 'json':
            report = {
                'generated_date': datetime.now().isoformat(),
                'total_vulnerabilities': len(vulns),
                'by_severity': {},
                'by_component': {},
                'top_risks': []
            }
            
            # Count by severity
            for severity in Severity:
                count = sum(1 for v in vulns if v.get('severity') == severity.value)
                report['by_severity'][severity.value] = count
            
            # Count by component
            components = {}
            for vuln in vulns:
                comp = vuln.get('affected_component', 'unknown').split(':')[0]
                components[comp] = components.get(comp, 0) + 1
            report['by_component'] = components
            
            # Top risks
            sorted_vulns = sorted(vulns, key=lambda v: v.get('priority', 0), reverse=True)
            report['top_risks'] = sorted_vulns[:10]
            
            return json.dumps(report, indent=2)
        
        elif format == 'markdown':
            md = f"# Vulnerability Report\n\n"
            md += f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
            
            md += f"## Summary\n\n"
            md += f"- Total Vulnerabilities: {len(vulns)}\n"
            
            # Severity breakdown
            md += f"\n### By Severity\n\n"
            for severity in Severity:
                count = sum(1 for v in vulns if v.get('severity') == severity.value)
                md += f"- {severity.value.upper()}: {count}\n"
            
            # Top vulnerabilities
            md += f"\n### Top Priority Vulnerabilities\n\n"
            sorted_vulns = sorted(vulns, key=lambda v: v.get('priority', 0), reverse=True)
            
            for vuln in sorted_vulns[:10]:
                md += f"#### {vuln.get('title', 'Unknown')}\n"
                md += f"- **CVE**: {vuln.get('cve_id', 'N/A')}\n"
                md += f"- **Severity**: {vuln.get('severity', 'unknown').upper()}\n"
                md += f"- **Component**: {vuln.get('affected_component', 'unknown')}\n"
                md += f"- **Priority Score**: {vuln.get('priority', 0)}\n"
                md += f"- **Remediation**: {vuln.get('remediation', 'No remediation available')}\n\n"
            
            return md
        
        else:
            raise ValueError(f"Unknown format: {format}")
    
    async def auto_remediate(self, max_risk_score: int = 80, dry_run: bool = True):
        """Automatically remediate high-risk vulnerabilities"""
        # Get high-risk vulnerabilities
        vulns = self.db.get_vulnerabilities(status=VulnerabilityStatus.NEW)
        high_risk = [v for v in vulns if v.get('risk_score', 0) >= max_risk_score]
        
        logger.info(f"Found {len(high_risk)} high-risk vulnerabilities for auto-remediation")
        
        remediated = []
        failed = []
        
        for vuln in high_risk:
            vuln_id = vuln['vuln_id']
            logger.info(f"Attempting to remediate {vuln_id}")
            
            # Generate remediation plan
            patch = await self.remediation.generate_remediation_plan(vuln_id)
            
            if patch:
                # Apply patch
                success = await self.remediation.apply_patch(patch, dry_run=dry_run)
                
                if success:
                    remediated.append(vuln_id)
                else:
                    failed.append(vuln_id)
            else:
                logger.warning(f"No remediation plan available for {vuln_id}")
                failed.append(vuln_id)
        
        return {
            'remediated': remediated,
            'failed': failed,
            'dry_run': dry_run
        }
    
    async def continuous_monitoring(self, targets: List[str]):
        """Run continuous vulnerability monitoring"""
        logger.info("Starting continuous vulnerability monitoring")
        
        while True:
            try:
                # Scan environment
                scan_result = await self.scan_environment(targets)
                logger.info(f"Scan complete: {scan_result}")
                
                # Auto-remediate critical vulnerabilities
                if scan_result['critical_count'] > 0:
                    logger.info("Critical vulnerabilities found, attempting auto-remediation")
                    remediation_result = await self.auto_remediate(max_risk_score=90, dry_run=False)
                    logger.info(f"Remediation result: {remediation_result}")
                
                # Generate and save report
                report = await self.generate_report('json')
                report_file = Path(f"/var/log/security/vuln-reports/report_{scan_result['scan_id']}.json")
                report_file.parent.mkdir(parents=True, exist_ok=True)
                report_file.write_text(report)
                
            except Exception as e:
                logger.error(f"Error in continuous monitoring: {str(e)}")
            
            # Wait for next scan
            await asyncio.sleep(self.scan_interval)


async def main():
    """Main entry point"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Vulnerability Management System')
    parser.add_argument('command', choices=['scan', 'report', 'remediate', 'monitor'],
                       help='Command to execute')
    parser.add_argument('--targets', nargs='+', help='Targets to scan')
    parser.add_argument('--format', choices=['json', 'markdown'], default='json',
                       help='Report format')
    parser.add_argument('--max-risk', type=int, default=80,
                       help='Maximum risk score for auto-remediation')
    parser.add_argument('--dry-run', action='store_true',
                       help='Dry run mode for remediation')
    
    args = parser.parse_args()
    
    vms = VulnerabilityManagementSystem()
    
    if args.command == 'scan':
        if not args.targets:
            print("Error: --targets required for scan")
            return
        
        result = await vms.scan_environment(args.targets)
        print(json.dumps(result, indent=2))
    
    elif args.command == 'report':
        report = await vms.generate_report(args.format)
        print(report)
    
    elif args.command == 'remediate':
        result = await vms.auto_remediate(args.max_risk, args.dry_run)
        print(json.dumps(result, indent=2))
    
    elif args.command == 'monitor':
        if not args.targets:
            # Default targets
            args.targets = [
                '/var/lib/docker',
                'nginx:latest',
                'ubuntu:latest'
            ]
        
        await vms.continuous_monitoring(args.targets)


if __name__ == "__main__":
    asyncio.run(main())