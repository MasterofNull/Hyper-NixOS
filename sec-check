#!/usr/bin/env python3
"""
Security Checker - System vulnerability assessment
Usage: sec-check [target] [options]
"""

import asyncio
import subprocess
import json
import sys
import os
from pathlib import Path
from datetime import datetime
import argparse

class SecurityChecker:
    """System security checker"""
    
    def __init__(self):
        self.report_dir = Path("/var/log/security/reports")
        self.report_dir.mkdir(parents=True, exist_ok=True)
        self.checks_performed = []
        self.issues_found = []
    
    async def check_system(self, quick: bool = False):
        """Check system security"""
        print("Checking system security...")
        
        # Package updates
        print("  [1/5] Checking for updates...")
        await self._check_updates()
        
        # Services
        print("  [2/5] Checking services...")
        await self._check_services()
        
        # File permissions
        print("  [3/5] Checking file permissions...")
        await self._check_permissions()
        
        # Firewall
        print("  [4/5] Checking firewall...")
        await self._check_firewall()
        
        # Users and authentication
        if not quick:
            print("  [5/5] Checking authentication...")
            await self._check_auth()
        else:
            print("  [5/5] Skipping authentication check (quick mode)")
        
        self.checks_performed.append('system')
    
    async def check_containers(self):
        """Check Docker container security"""
        print("Checking container security...")
        
        try:
            # Check if Docker is installed
            result = subprocess.run(['which', 'docker'], capture_output=True)
            if result.returncode != 0:
                print("  Docker not installed, skipping container checks")
                return
            
            # Get running containers
            cmd = ['docker', 'ps', '--format', '{{.ID}}|{{.Names}}|{{.Image}}']
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                print("  Error accessing Docker")
                return
            
            containers = stdout.decode().strip().split('\n')
            containers = [c for c in containers if c]
            
            print(f"  Found {len(containers)} running containers")
            
            for container_info in containers:
                parts = container_info.split('|')
                if len(parts) >= 3:
                    container_id = parts[0]
                    container_name = parts[1]
                    image = parts[2]
                    
                    print(f"  Checking {container_name}...")
                    await self._check_container(container_id, container_name, image)
            
            self.checks_performed.append('containers')
            
        except Exception as e:
            print(f"  Error checking containers: {str(e)}")
    
    async def check_vulnerabilities(self, target: str = '/'):
        """Check for known vulnerabilities"""
        print(f"Checking for vulnerabilities in {target}...")
        
        # Try to use Trivy if available
        try:
            result = subprocess.run(['which', 'trivy'], capture_output=True)
            if result.returncode == 0:
                await self._scan_with_trivy(target)
            else:
                print("  Trivy not installed, using basic checks")
                await self._basic_vulnerability_check()
        except:
            await self._basic_vulnerability_check()
        
        self.checks_performed.append('vulnerabilities')
    
    async def check_compliance(self, standard: str = 'basic'):
        """Check security compliance"""
        print(f"Checking {standard} compliance...")
        
        if standard == 'basic':
            # Basic security compliance checks
            checks = [
                ('SSH root login disabled', self._check_ssh_root_login),
                ('Password complexity enforced', self._check_password_policy),
                ('Unattended upgrades configured', self._check_auto_updates),
                ('Audit logging enabled', self._check_audit_logging)
            ]
            
            for check_name, check_func in checks:
                print(f"  Checking: {check_name}...")
                await check_func()
        
        self.checks_performed.append(f'compliance-{standard}')
    
    async def _check_updates(self):
        """Check for system updates"""
        try:
            # For Debian/Ubuntu systems
            cmd = ['apt-get', '-s', 'upgrade']
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, _ = await process.communicate()
            
            output = stdout.decode()
            
            # Count packages to upgrade
            upgrade_count = output.count('Inst ')
            security_count = output.count('security')
            
            if security_count > 0:
                self.issues_found.append({
                    'type': 'system',
                    'severity': 'high',
                    'title': f'{security_count} security updates available',
                    'description': 'Security updates should be installed immediately',
                    'remediation': 'Run: sudo apt-get update && sudo apt-get upgrade'
                })
            elif upgrade_count > 20:
                self.issues_found.append({
                    'type': 'system',
                    'severity': 'medium',
                    'title': f'{upgrade_count} updates available',
                    'description': 'System has many pending updates',
                    'remediation': 'Run: sudo apt-get update && sudo apt-get upgrade'
                })
                
        except Exception as e:
            print(f"    Could not check updates: {str(e)}")
    
    async def _check_services(self):
        """Check for insecure services"""
        insecure_services = {
            'telnet': 'Replace with SSH',
            'ftp': 'Replace with SFTP/SCP',
            'rsh': 'Replace with SSH',
            'rlogin': 'Replace with SSH',
            'tftp': 'Replace with secure alternative'
        }
        
        for service, recommendation in insecure_services.items():
            try:
                cmd = ['systemctl', 'is-active', service]
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                stdout, _ = await process.communicate()
                
                if stdout.decode().strip() == 'active':
                    self.issues_found.append({
                        'type': 'service',
                        'severity': 'high',
                        'title': f'Insecure service {service} is running',
                        'description': f'{service} transmits data in cleartext',
                        'remediation': f'Disable: sudo systemctl stop {service} && sudo systemctl disable {service}\n{recommendation}'
                    })
            except:
                pass
    
    async def _check_permissions(self):
        """Check critical file permissions"""
        permission_checks = {
            '/etc/passwd': ('644', 'World-writable passwd file'),
            '/etc/shadow': ('640', 'Incorrect shadow file permissions'),
            '/etc/ssh/sshd_config': ('600', 'SSH config too permissive'),
            '/etc/sudoers': ('440', 'Sudoers file permissions incorrect')
        }
        
        for filepath, (expected_perms, issue_desc) in permission_checks.items():
            try:
                if Path(filepath).exists():
                    stat_info = os.stat(filepath)
                    current_perms = oct(stat_info.st_mode)[-3:]
                    
                    if current_perms != expected_perms:
                        self.issues_found.append({
                            'type': 'permissions',
                            'severity': 'high',
                            'title': issue_desc,
                            'description': f'{filepath} has permissions {current_perms}, should be {expected_perms}',
                            'remediation': f'Run: sudo chmod {expected_perms} {filepath}'
                        })
            except:
                pass
    
    async def _check_firewall(self):
        """Check firewall configuration"""
        # Try UFW first
        try:
            cmd = ['ufw', 'status']
            process = await asyncio.create_subprocess_exec(
                'sudo', *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, _ = await process.communicate()
            
            output = stdout.decode()
            
            if 'Status: inactive' in output:
                self.issues_found.append({
                    'type': 'firewall',
                    'severity': 'critical',
                    'title': 'Firewall is disabled',
                    'description': 'No firewall protection is active',
                    'remediation': 'Enable firewall: sudo ufw enable'
                })
                return
                
        except:
            # Try iptables
            try:
                cmd = ['iptables', '-L', '-n']
                process = await asyncio.create_subprocess_exec(
                    'sudo', *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                stdout, _ = await process.communicate()
                
                output = stdout.decode()
                if output.count('\n') < 10 and 'ACCEPT' in output and 'all' in output:
                    self.issues_found.append({
                        'type': 'firewall',
                        'severity': 'high',
                        'title': 'No firewall rules configured',
                        'description': 'Firewall has no filtering rules',
                        'remediation': 'Configure firewall rules or use UFW'
                    })
            except:
                pass
    
    async def _check_auth(self):
        """Check authentication configuration"""
        # Check for users with empty passwords
        try:
            cmd = ['awk', '-F:', '($2 == "") {print $1}', '/etc/shadow']
            process = await asyncio.create_subprocess_exec(
                'sudo', *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, _ = await process.communicate()
            
            users = stdout.decode().strip().split('\n')
            users = [u for u in users if u]
            
            if users:
                self.issues_found.append({
                    'type': 'authentication',
                    'severity': 'critical',
                    'title': f'Users without passwords: {", ".join(users)}',
                    'description': 'These users can login without a password',
                    'remediation': 'Set passwords: sudo passwd <username>'
                })
        except:
            pass
    
    async def _check_container(self, container_id: str, name: str, image: str):
        """Check individual container security"""
        # Check if running as root
        try:
            cmd = ['docker', 'inspect', container_id, '--format', '{{.Config.User}}']
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, _ = await process.communicate()
            
            user = stdout.decode().strip()
            if not user or user == 'root' or user == '0':
                self.issues_found.append({
                    'type': 'container',
                    'severity': 'medium',
                    'title': f'Container {name} running as root',
                    'description': 'Container processes should not run as root',
                    'remediation': 'Add "USER nonroot" to Dockerfile'
                })
        except:
            pass
        
        # Check if privileged
        try:
            cmd = ['docker', 'inspect', container_id, '--format', '{{.HostConfig.Privileged}}']
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, _ = await process.communicate()
            
            if stdout.decode().strip() == 'true':
                self.issues_found.append({
                    'type': 'container',
                    'severity': 'critical',
                    'title': f'Container {name} running in privileged mode',
                    'description': 'Privileged containers can escape containment',
                    'remediation': 'Remove --privileged flag'
                })
        except:
            pass
    
    async def _scan_with_trivy(self, target: str):
        """Scan with Trivy vulnerability scanner"""
        try:
            if target.startswith('/'):
                cmd = ['trivy', 'fs', '--severity', 'CRITICAL,HIGH', target]
            else:
                cmd = ['trivy', 'image', '--severity', 'CRITICAL,HIGH', target]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            
            output = stdout.decode()
            
            # Simple parsing of Trivy output
            if 'Total:' in output:
                for line in output.split('\n'):
                    if 'Total:' in line and ('CRITICAL' in line or 'HIGH' in line):
                        self.issues_found.append({
                            'type': 'vulnerability',
                            'severity': 'high',
                            'title': f'Vulnerabilities found in {target}',
                            'description': line.strip(),
                            'remediation': 'Update packages or base image'
                        })
                        break
        except:
            pass
    
    async def _basic_vulnerability_check(self):
        """Basic vulnerability checks without scanner"""
        # Check for old kernel
        try:
            cmd = ['uname', '-r']
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, _ = await process.communicate()
            
            kernel = stdout.decode().strip()
            # Very basic check - kernel older than 5.0 might have issues
            major_version = int(kernel.split('.')[0])
            if major_version < 5:
                self.issues_found.append({
                    'type': 'vulnerability',
                    'severity': 'medium',
                    'title': 'Outdated kernel version',
                    'description': f'Kernel {kernel} may have unpatched vulnerabilities',
                    'remediation': 'Update kernel: sudo apt-get update && sudo apt-get upgrade'
                })
        except:
            pass
    
    async def _check_ssh_root_login(self):
        """Check if SSH root login is disabled"""
        try:
            with open('/etc/ssh/sshd_config', 'r') as f:
                config = f.read()
                
            if 'PermitRootLogin yes' in config:
                self.issues_found.append({
                    'type': 'compliance',
                    'severity': 'high',
                    'title': 'SSH root login enabled',
                    'description': 'Direct root login via SSH is a security risk',
                    'remediation': 'Set "PermitRootLogin no" in /etc/ssh/sshd_config'
                })
        except:
            pass
    
    async def _check_password_policy(self):
        """Check password complexity requirements"""
        try:
            if Path('/etc/security/pwquality.conf').exists():
                with open('/etc/security/pwquality.conf', 'r') as f:
                    config = f.read()
                
                if 'minlen' not in config or 'minlen = 8' in config:
                    self.issues_found.append({
                        'type': 'compliance',
                        'severity': 'medium',
                        'title': 'Weak password policy',
                        'description': 'Password complexity requirements are not strict enough',
                        'remediation': 'Configure /etc/security/pwquality.conf with minlen=14 and complexity requirements'
                    })
        except:
            pass
    
    async def _check_auto_updates(self):
        """Check if automatic updates are configured"""
        try:
            result = subprocess.run(['which', 'unattended-upgrades'], capture_output=True)
            if result.returncode != 0:
                self.issues_found.append({
                    'type': 'compliance',
                    'severity': 'medium',
                    'title': 'Automatic updates not configured',
                    'description': 'Security patches should be applied automatically',
                    'remediation': 'Install: sudo apt-get install unattended-upgrades'
                })
        except:
            pass
    
    async def _check_audit_logging(self):
        """Check if audit logging is enabled"""
        try:
            cmd = ['systemctl', 'is-active', 'auditd']
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, _ = await process.communicate()
            
            if stdout.decode().strip() != 'active':
                self.issues_found.append({
                    'type': 'compliance',
                    'severity': 'medium',
                    'title': 'Audit logging not enabled',
                    'description': 'System audit trail is important for security monitoring',
                    'remediation': 'Install and enable: sudo apt-get install auditd && sudo systemctl enable auditd'
                })
        except:
            pass
    
    def generate_report(self, output_format: str = 'text', output_file: str = None):
        """Generate security report"""
        timestamp = datetime.now()
        
        report_data = {
            'timestamp': timestamp.isoformat(),
            'checks_performed': self.checks_performed,
            'issues_found': len(self.issues_found),
            'issues': self.issues_found,
            'summary': {
                'critical': len([i for i in self.issues_found if i['severity'] == 'critical']),
                'high': len([i for i in self.issues_found if i['severity'] == 'high']),
                'medium': len([i for i in self.issues_found if i['severity'] == 'medium']),
                'low': len([i for i in self.issues_found if i['severity'] == 'low'])
            }
        }
        
        if output_format == 'json':
            report = json.dumps(report_data, indent=2)
        else:
            # Text format
            report = f"""Security Check Report
Generated: {timestamp.strftime('%Y-%m-%d %H:%M:%S')}

Checks Performed: {', '.join(self.checks_performed)}
Total Issues Found: {len(self.issues_found)}

Summary:
  Critical: {report_data['summary']['critical']}
  High: {report_data['summary']['high']}
  Medium: {report_data['summary']['medium']}
  Low: {report_data['summary']['low']}

"""
            
            if self.issues_found:
                # Group by severity
                for severity in ['critical', 'high', 'medium', 'low']:
                    issues = [i for i in self.issues_found if i['severity'] == severity]
                    if issues:
                        report += f"\n{severity.upper()} Priority Issues:\n"
                        report += "=" * 50 + "\n\n"
                        
                        for issue in issues:
                            report += f"Issue: {issue['title']}\n"
                            report += f"Type: {issue['type']}\n"
                            report += f"Description: {issue['description']}\n"
                            report += f"Remediation: {issue['remediation']}\n"
                            report += "\n"
            else:
                report += "\nNo security issues found!\n"
        
        # Save to file if requested
        if output_file:
            with open(output_file, 'w') as f:
                f.write(report)
            print(f"\nReport saved to: {output_file}")
        else:
            print(report)
        
        return report_data


async def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Security Checker - System vulnerability assessment',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Check types:
  all          Run all security checks (default)
  system       Check system security only
  containers   Check Docker containers only
  vuln         Check for vulnerabilities only
  compliance   Check security compliance only

Examples:
  sec-check                        # Run all checks
  sec-check system                 # System checks only
  sec-check containers             # Container checks only
  sec-check --quick                # Quick scan (skip slow checks)
  sec-check --output report.json   # Save JSON report
  sec-check --fix                  # Show remediation commands
        """
    )
    
    parser.add_argument('check_type', nargs='?', default='all',
                       choices=['all', 'system', 'containers', 'vuln', 'compliance'],
                       help='Type of check to perform')
    parser.add_argument('--quick', '-q', action='store_true',
                       help='Quick scan (skip time-consuming checks)')
    parser.add_argument('--output', '-o',
                       help='Save report to file')
    parser.add_argument('--json', action='store_true',
                       help='Output in JSON format')
    parser.add_argument('--fix', action='store_true',
                       help='Show detailed remediation steps')
    
    args = parser.parse_args()
    
    # Create checker instance
    checker = SecurityChecker()
    
    # Run requested checks
    print("Security Check Starting...\n")
    
    if args.check_type == 'all':
        await checker.check_system(quick=args.quick)
        await checker.check_containers()
        await checker.check_vulnerabilities()
        await checker.check_compliance()
    elif args.check_type == 'system':
        await checker.check_system(quick=args.quick)
    elif args.check_type == 'containers':
        await checker.check_containers()
    elif args.check_type == 'vuln':
        await checker.check_vulnerabilities()
    elif args.check_type == 'compliance':
        await checker.check_compliance()
    
    print("\nGenerating report...")
    
    # Generate report
    output_format = 'json' if args.json else 'text'
    report_data = checker.generate_report(output_format, args.output)
    
    # Exit with appropriate code
    if report_data['summary']['critical'] > 0:
        sys.exit(2)  # Critical issues found
    elif report_data['summary']['high'] > 0:
        sys.exit(1)  # High priority issues found
    else:
        sys.exit(0)  # No major issues


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nCheck cancelled by user")
        sys.exit(130)
    except Exception as e:
        print(f"Error: {str(e)}")
        sys.exit(1)