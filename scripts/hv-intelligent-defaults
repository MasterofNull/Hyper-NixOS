#!/usr/bin/env bash
# Hyper-NixOS Intelligent Defaults Tool
# Demonstrates and tests the intelligent defaults framework
# Part of Design Ethos - Third Pillar: Learning Through Guidance

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/lib/system_discovery.sh"
source "${SCRIPT_DIR}/lib/intelligent_template_processor.sh"

# Colors
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly YELLOW='\033[1;33m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly NC='\033[0m'

# Print header
print_header() {
    echo -e "${CYAN}"
    cat << 'EOF'
╔════════════════════════════════════════════════════════════╗
║  Hyper-NixOS Intelligent Defaults Framework                ║
║  Learning Through Guidance - Best Practices as Default     ║
╚════════════════════════════════════════════════════════════╝
EOF
    echo -e "${NC}"
}

# Show system discovery report
cmd_discover() {
    print_header
    echo -e "${BOLD}System Discovery Report${NC}\n"
    generate_system_report text
    echo ""
}

# Show intelligent VM defaults
cmd_vm_defaults() {
    local os_type=${1:-linux}
    
    print_header
    echo -e "${BOLD}Intelligent VM Defaults for: ${os_type}${NC}\n"
    
    # Generate defaults
    generate_vm_defaults "$os_type" bash
    echo ""
}

# Generate VM profile from template
cmd_generate_profile() {
    local template=$1
    local vm_name=$2
    
    print_header
    echo -e "${BOLD}Generating VM Profile${NC}\n"
    
    generate_vm_profile "$template" "$vm_name"
    echo ""
}

# List intelligent templates
cmd_list_templates() {
    print_header
    list_intelligent_templates
    echo ""
}

# Interactive demo
cmd_demo() {
    print_header
    echo -e "${BOLD}Interactive Intelligent Defaults Demo${NC}\n"
    
    echo -e "${YELLOW}Step 1: System Discovery${NC}"
    echo "Detecting your hardware..."
    sleep 1
    
    local cpu_cores=$(get_cpu_cores)
    local total_ram=$(get_total_ram_mb)
    local storage_type=$(detect_storage_type)
    local virt_support=$(check_virt_support)
    local gpu=$(detect_gpu)
    
    echo -e "${GREEN}✓${NC} CPU: $cpu_cores cores (Virtualization: $virt_support)"
    echo -e "${GREEN}✓${NC} RAM: ${total_ram}MB"
    echo -e "${GREEN}✓${NC} Storage: $storage_type"
    echo -e "${GREEN}✓${NC} GPU: $gpu"
    echo ""
    
    echo -e "${YELLOW}Step 2: Calculating Intelligent Defaults${NC}"
    sleep 1
    
    local rec_vcpus=$(calculate_recommended_vcpus "$cpu_cores" 25 2)
    local rec_ram=$(calculate_recommended_ram "$total_ram" "$rec_vcpus" 2048)
    local rec_disk_format=$(recommend_disk_format "$storage_type")
    
    echo -e "${GREEN}✓${NC} Recommended vCPUs: $rec_vcpus (25% of $cpu_cores host cores)"
    echo -e "${GREEN}✓${NC} Recommended RAM: ${rec_ram}MB (2GB per vCPU)"
    echo -e "${GREEN}✓${NC} Recommended Disk Format: $rec_disk_format (optimal for $storage_type)"
    echo ""
    
    echo -e "${YELLOW}Step 3: Best Practice Reasoning${NC}"
    cat << EOF

Why these defaults?

  ${BOLD}vCPUs: $rec_vcpus${NC}
    Allocating 25% of host cores ensures:
    • VM has adequate CPU resources
    • Host OS remains responsive
    • Other VMs can run simultaneously
    • Balanced performance across workloads

  ${BOLD}RAM: ${rec_ram}MB${NC}
    2GB per vCPU follows industry best practices:
    • Prevents memory bottlenecks
    • Allows good application performance
    • Doesn't exceed 50% of host RAM
    • Leaves resources for host and other VMs

  ${BOLD}Disk Format: $rec_disk_format${NC}
EOF

    if [ "$rec_disk_format" = "qcow2" ]; then
        cat << EOF
    qcow2 is optimal for $storage_type because:
    • Supports snapshots for easy backup/restore
    • Thin provisioning saves disk space
    • Copy-on-write is efficient on fast storage
    • Industry-standard format with broad support
EOF
    else
        cat << EOF
    raw is optimal for $storage_type because:
    • Better performance on spinning disks
    • No overhead from CoW operations
    • Simpler format for sequential access
    • Direct disk mapping
EOF
    fi
    
    echo ""
    echo -e "${CYAN}These defaults guide you to excellence through best practices!${NC}"
    echo ""
}

# Help message
cmd_help() {
    cat << EOF
Hyper-NixOS Intelligent Defaults Tool

Usage: hv-intelligent-defaults <command> [arguments]

Commands:
  discover              Show complete system discovery report
  vm-defaults [os]      Show intelligent VM defaults for OS type
                        OS types: linux, windows, minimal
  generate <template> <name>
                        Generate VM profile from intelligent template
  list-templates        List available intelligent templates
  demo                  Interactive demonstration of intelligent defaults
  help                  Show this help message

Examples:
  # Discover system capabilities
  hv-intelligent-defaults discover

  # See intelligent defaults for Linux VM
  hv-intelligent-defaults vm-defaults linux

  # Generate VM profile
  hv-intelligent-defaults generate intelligent-linux-desktop my-dev-vm

  # Interactive demo
  hv-intelligent-defaults demo

Part of Design Ethos - Third Pillar: Learning Through Guidance
EOF
}

# Main
main() {
    local command=${1:-help}
    shift || true
    
    case "$command" in
        discover)
            cmd_discover "$@"
            ;;
        vm-defaults)
            cmd_vm_defaults "$@"
            ;;
        generate|gen)
            if [ $# -lt 2 ]; then
                echo "Error: generate requires template name and VM name" >&2
                echo "Usage: hv-intelligent-defaults generate <template> <vm-name>" >&2
                exit 1
            fi
            cmd_generate_profile "$@"
            ;;
        list-templates|list)
            cmd_list_templates
            ;;
        demo)
            cmd_demo
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            echo "Unknown command: $command" >&2
            echo "Run 'hv-intelligent-defaults help' for usage information" >&2
            exit 1
            ;;
    esac
}

if [ "${BASH_SOURCE[0]}" = "$0" ]; then
    main "$@"
fi
