#!/usr/bin/env python3
"""
Vulnerability Scanner
Find, track, and fix security vulnerabilities
"""

import asyncio
import json
import subprocess
from pathlib import Path
from datetime import datetime
import argparse
import sys

class VulnScanner:
    """Vulnerability scanner and manager"""
    
    def __init__(self):
        self.db_path = Path("/var/lib/security/vulns.db")
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
    
    async def scan(self, targets: List[str], fix: bool = False):
        """Scan targets for vulnerabilities"""
        all_vulns = []
        
        for target in targets:
            print(f"[*] Scanning {target}")
            
            if target.startswith('/'):
                # Filesystem scan
                vulns = await self._scan_filesystem(target)
            elif ':' in target or '.' in target:
                # Container/image scan
                vulns = await self._scan_container(target)
            else:
                print(f"[!] Unknown target type: {target}")
                continue
            
            all_vulns.extend(vulns)
            
            # Show summary
            if vulns:
                critical = sum(1 for v in vulns if v['severity'] == 'CRITICAL')
                high = sum(1 for v in vulns if v['severity'] == 'HIGH')
                
                print(f"[!] Found {len(vulns)} vulnerabilities")
                if critical > 0:
                    print(f"    CRITICAL: {critical}")
                if high > 0:
                    print(f"    HIGH: {high}")
                
                if fix and (critical > 0 or high > 0):
                    await self._fix_vulns(vulns)
            else:
                print(f"[+] No vulnerabilities found")
        
        return all_vulns
    
    async def _scan_container(self, image: str) -> List[Dict]:
        """Scan container/image with Trivy"""
        cmd = ['trivy', 'image', '--format', 'json', '--quiet', image]
        
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode not in [0, 1]:
                print(f"[!] Scan failed: {stderr.decode()}")
                return []
            
            # Parse results
            data = json.loads(stdout.decode())
            vulns = []
            
            for result in data.get('Results', []):
                for vuln in result.get('Vulnerabilities', []):
                    vulns.append({
                        'id': vuln.get('VulnerabilityID'),
                        'package': vuln.get('PkgName'),
                        'version': vuln.get('InstalledVersion'),
                        'fixed': vuln.get('FixedVersion', 'None'),
                        'severity': vuln.get('Severity'),
                        'title': vuln.get('Title', '')
                    })
            
            return vulns
            
        except Exception as e:
            print(f"[!] Error: {str(e)}")
            return []
    
    async def _scan_filesystem(self, path: str) -> List[Dict]:
        """Scan filesystem path"""
        cmd = ['trivy', 'fs', '--format', 'json', '--quiet', path]
        
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode not in [0, 1]:
                return []
            
            # Parse results (same format as container scan)
            data = json.loads(stdout.decode())
            vulns = []
            
            for result in data.get('Results', []):
                for vuln in result.get('Vulnerabilities', []):
                    vulns.append({
                        'id': vuln.get('VulnerabilityID'),
                        'package': vuln.get('PkgName'),
                        'version': vuln.get('InstalledVersion'),
                        'fixed': vuln.get('FixedVersion', 'None'),
                        'severity': vuln.get('Severity'),
                        'title': vuln.get('Title', '')
                    })
            
            return vulns
            
        except:
            return []
    
    async def _fix_vulns(self, vulns: List[Dict]):
        """Attempt to fix vulnerabilities"""
        print("\n[*] Attempting fixes...")
        
        # Group by package manager
        apt_packages = []
        npm_packages = []
        pip_packages = []
        
        for vuln in vulns:
            if vuln['severity'] not in ['CRITICAL', 'HIGH']:
                continue
            
            if vuln['fixed'] and vuln['fixed'] != 'None':
                package = vuln['package']
                
                # Detect package type
                if any(x in package for x in ['lib', 'dev', '-dev']):
                    apt_packages.append(f"{package}={vuln['fixed']}")
                elif 'node' in package or 'npm' in package:
                    npm_packages.append(f"{package}@{vuln['fixed']}")
                elif 'py' in package or 'python' in package:
                    pip_packages.append(f"{package}=={vuln['fixed']}")
        
        # Apply fixes
        if apt_packages:
            print(f"[*] Updating APT packages: {len(apt_packages)}")
            cmd = f"sudo apt-get update && sudo apt-get install -y {' '.join(apt_packages[:5])}"
            print(f"    Run: {cmd}")
        
        if npm_packages:
            print(f"[*] Updating NPM packages: {len(npm_packages)}")
            for pkg in npm_packages[:5]:
                print(f"    npm install {pkg}")
        
        if pip_packages:
            print(f"[*] Updating Python packages: {len(pip_packages)}")
            for pkg in pip_packages[:5]:
                print(f"    pip install --upgrade {pkg}")
    
    def report(self, format: str = 'summary'):
        """Generate vulnerability report"""
        # Load recent scan results
        vulns = self._load_recent_vulns()
        
        if format == 'summary':
            print("\nVulnerability Summary")
            print("====================")
            
            total = len(vulns)
            critical = sum(1 for v in vulns if v.get('severity') == 'CRITICAL')
            high = sum(1 for v in vulns if v.get('severity') == 'HIGH')
            
            print(f"Total: {total}")
            print(f"Critical: {critical}")
            print(f"High: {high}")
            
            if critical > 0:
                print("\nCritical Vulnerabilities:")
                for v in vulns:
                    if v.get('severity') == 'CRITICAL':
                        print(f"  - {v['id']}: {v['package']} ({v['title'][:50]}...)")
        
        elif format == 'full':
            print(json.dumps(vulns, indent=2))
    
    def _load_recent_vulns(self) -> List[Dict]:
        """Load recent vulnerability data"""
        # This would load from the database in a real implementation
        # For now, return empty list
        return []


async def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Vulnerability Scanner',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Commands:
  scan      Scan for vulnerabilities
  fix       Scan and attempt fixes
  report    Show vulnerability report

Examples:
  vuln scan /
  vuln scan nginx:latest
  vuln fix /var/www
  vuln report
        """
    )
    
    parser.add_argument('command', choices=['scan', 'fix', 'report'],
                       help='Command to run')
    parser.add_argument('targets', nargs='*', 
                       help='Targets to scan (paths or images)')
    parser.add_argument('-o', '--output', help='Save results to file')
    
    args = parser.parse_args()
    
    scanner = VulnScanner()
    
    if args.command == 'scan':
        if not args.targets:
            args.targets = ['/']  # Default to root filesystem
        
        vulns = await scanner.scan(args.targets)
        
        if args.output:
            with open(args.output, 'w') as f:
                json.dump(vulns, f, indent=2)
            print(f"\n[+] Results saved to {args.output}")
    
    elif args.command == 'fix':
        if not args.targets:
            args.targets = ['/']
        
        await scanner.scan(args.targets, fix=True)
    
    elif args.command == 'report':
        scanner.report('summary')


if __name__ == "__main__":
    # Check if Trivy is installed
    try:
        subprocess.run(['which', 'trivy'], check=True, capture_output=True)
    except:
        print("[!] Trivy not found. Install with:")
        print("    curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin")
        sys.exit(1)
    
    asyncio.run(main())